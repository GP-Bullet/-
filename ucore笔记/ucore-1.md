启动引导

qemu使用我们提供的rustsbi的bin文件做为引导程序来启动OS



我们OS自己实现的printf函数，想要真正地输出到我们外部运行的shell上被我们看到，是要经过qemu的。实际上，在启动时sbi已经帮我们初始化好了，经过qemu模拟出来的串口，最终打印到我们外部的shell上的



**RustSBI 是什么？**

SBI 是 RISC-V 的一种底层规范，RustSBI 是它的一种实现。 操作系统内核与 RustSBI 的关系有点像应用与操作系统内核的关系，后者向前者提供一定的服务。只是SBI提供的服务很少， 比如关机，显示字符串，读入字符串等。



每次在make run之前，尽量先执行make clean以删除缓存，特别是在切换ch分支之后



make run它完成了内核代码的编译生成kernel，并按照QEMUOPTS变量指定的参数加载我们的kernel，“加电”启动qemu。 此时，CPU 的其它通用寄存器清零，而 PC 会指向 0x1000 的位置，这里有固化在硬件中的一小段引导代码，它会很快跳转到 0x80000000 的 RustSBI 处。 RustSBI完成硬件初始化后，会跳转到 $(KERNEL_BIN) 所在内存位置 0x80200000 处， 执行我们操作系统的第一条指令。



那么我们是如何把字符串真正地打印到 shell 上的呢？ 我们 调用consputc 函数输出一个 char 到 shell，而 consputc 函数其实就是调用了 sbi.c 之中的 console_putchar 函数。这个　console_putchar 函数的本质是调用了 sbi_call。剥开层层套娃，大家可以发现打印的最终实现是使用 sbi 帮助我们包装好的 ecall 汇编代码通过指定 ecall 的 idx 为 SBI_CONSOLE_PUTCHAR, 并将我们的字符做为参数传入到 ecall 指定的寄存器之中完成一次系统调用来实现的。

本来，作为一个 OS，串口输出(也就是输出到 shell)的事情也应该我们自己来做，但这里为了简化这些硬件强相关的实现，我们利用 rust-sbi 的 M 态支持。这也是 riscv 灵活性的一个体现。







在RISC-V架构中，主要有以下几种状态：

1. 用户态（User Mode）：运行应用程序的常规模式，只能访问自己的虚拟地址空间。
2. 监管态（Supervisor Mode）：运行操作系统内核代码的模式，能够访问所有物理地址空间和一些特权指令。
3. 机器态（Machine Mode）：最高特权级别的模式，用于启动和配置处理器，也可以访问所有物理地址空间并执行所有指令。
4. 调试态（Debug Mode）：用于调试处理器和程序的特殊模式。

而在x86架构中，主要有以下几种状态：

1. 实模式（Real Mode）：较早的x86工作模式，16位寻址，没有特权级，可访问1M内存。
2. 保护模式（Protected Mode）：引入了特权级的概念，支持虚拟内存管理和分页机制等，32位或64位寻址。
3. 虚拟86模式（Virtual-8086 Mode）：一种特殊的保护模式，用于在32位或64位系统下运行16位应用程序。
4. 系统管理模式（System Management Mode）：用于系统管理任务和处理硬件错误等。

RISC-V架构与x86架构最主要的不同点之一是，RISC-V只定义了少数几种特权级，每种特权级之间的限制和区别比x86明确和简单。相比之下，x86架构中的特权级非常复杂和分层，繁琐的特权级划分导致了指令和操作的复杂和不同系统的差异。





---
链接脚本
 entry  布置好栈  -> 调用main  ->  清理bss段 ->





Qemu 启动后 PC 被初始化为 `0x1000`

当位于 `0x1010` 的指令执行完毕后，下一条待执行的指令位于 RustSBI 的入口，也即 `0x80000000` ，这意味着我们即将把控制权转交给 RustSBI 

控制权能否被移交给我们的内核，0x80200000，内核第一条指令

我们可以检查此时栈指针 `sp` 的值，可以发现它目前是 0 。下一节我们将设置好栈空间，使得内核代码可以正常进行函数调用，随后将控制权转交给 Rust 代码











