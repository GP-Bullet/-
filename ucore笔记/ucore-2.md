应用程序不能执行某些可能破会计算机系统的指令

我们还需要确保应用程序能够得到操作系统的服务，即应用程序和操作系统还需要有交互的手段。使得低特权级软件都只能做高特权级软件允许它做的，且低特权级软件的超出其能力的要求必须寻求高特权级软件的帮助

操作系统需要提供相应的控制流，能在执行 `eret` 前准备和恢复用户态执行应用程序的上下文。其次，在应用程序调用 `ecall` 指令后，能够保存用户态执行应用程序的上下文，便于后续的恢复；且还要坚持应用程序发出的服务请求是安全的



用户态应用直接触发从用户态到内核态的 **异常控制流** 的原因总体上可以分为两种：执行 `Trap类异常` 指令和执行了会产生 `Fault类异常` 的指令 。



在user/lib/arch/riscv下的syscall_arch.h为我们包装好了使用riscv汇编调用系统调用ecall的函数接口

---

代码导读

编写多个应用小程序，修改编译应用所需的 `linker.ld` 文件来 调整程序的内存布局 ，让操作系统能够把应用加载到指定内存地址后顺利启动并运行应用程序。

－－－－－－－－

系统调用流程

用户程序代码怎么触发异常》trapinit中的寄存器保存trap结构体规范然后跳转到》处理异常号》syscall》id》调用相应的例程》恢复》回到用户程序继执行同时避免死循环

－－－－－－－

- 静态编码：通过一定的编程技巧，把应用程序代码和批处理操作系统代码“绑定”在一起。
- 动态加载：基于静态编码留下的“绑定”信息，操作系统可以找到应用程序文件二进制代码的起始地址和长度，并能加载到内存中运行。

这里与硬件相关且比较困难的地方是如何让在内核态的批处理操作系统启动应用程序，且能让应用程序在用户态正常执行。

--------------------------------------------------

u2执行流程：执行到内核main -> trap_init() -> uservec -> 保存用户空间的寄存器到 TRAPFRAME 结构 -> 跳转到usertrap() -> syscall()->执行具体的系统调用如**SYS_write**或**SYS_exit** -> loader_init() -> run_next_app() 切换app-> load_app() ->返回用户态usertrapret() -> userret() 

问1：何时是U态到S态，问2：第一个用户程序是怎么开始的
