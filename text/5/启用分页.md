





启用分页机制，我们要按顺序做好三件事。
（1）准备好页目录表及页表。
（2）将页表地址写入控制寄存器 cr3。
（3）寄存器 cr0 的 PG 位置 1。PG 位为 1 后便进入了内存分页运行机制，段部件输出的线性地址成为虚拟地址

在将 PG 位置 1 之前，系统都是在内存分段机制下工作，段部件输出的线
性地址便直接是物理地址，也就意味着在第 2 步中，cr3 寄存器中的页表地址是真实的物理地址。

![image-20231014134639494](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014134639494.png)



![image-20231014141027530](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014141027530.png)

页目录表的位置，放在物理地址 0x100000 处

第一个页表的放在物理地址0x101000。





需要将虚拟地址 0xc0000000之上的 1MB 地址映射到物理内存 1MB 之内



#### 为什么要在两处指向同一个页表？



原因是我们在加载内核之前，程序中运行的一直都是 loader，它本身的代码都是在 1MB 之内，必须保证之前段机制下的线性地址和分页后的虚拟地址对应的物理地址一致。
**第 0 个页目录项代表的页表，其表示的空间是 0～0x3fffff，包括了 1MB（0～0xfffff），所以用了第 0 项来**
**保证 loader 在分页机制下依然运行正确。**

那为什么也要把该地址放置到第 768 项呢？前面说过啦，我们将来会把**操作系统内核放在低端 1M 物理内存空间，但操作系统的虚拟地址是 0xc0000000 以上，该虚拟地址对应的页目录项是第 768 个。**

这个算起来容易，0xc0000000 的高 10 位是 0x300，即十进制的 768。**这样虚拟地址 0xc0000000～0xc03fffff 之间的内存都指向的是低端 4MB 之内的物理地址，**这自然包括操作系统所占的低端 1MB 物理内存。从而实现了操作系统高 3GB 以上的虚拟地址对应到了低端 1MB，也就是如前所说我们内核所占的就是低端 1MB。



