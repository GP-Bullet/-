
![image-20231016105708520](/home/bulet/snap/typora/86/.config/Typora/typora-user-images/image-20231016110042860.png)

![image-20231016110115795](/home/bulet/snap/typora/86/.config/Typora/typora-user-images/image-20231016110115795.png)

![屏幕截图 2023-10-16 105701](/mnt/hgfs/sharewin/屏幕截图 2023-10-16 105701.png)

- 第一行

  e_ident 数组，前 4 字节是固定的 elf 魔数，正如您看到的，它们是 0x7f 和字符 ELF 的 ASCII：0x45、0x4c、0x46。所以您在显示区看到了 ELF 的三个字符。紧跟其后的三个 1 分别是 e_ident[4]、e_ident[5]、e_ident[6]三个成员，代表的意义是 32 位 elf 文件、小端字节序、当前版本。

  后面的 9 个 00 是 e_ident[7]～e_ident[15]，这些确实都已经初始化为 0。

- 第二行。
  第 1 个下画线处的内容是 02 00，由于是小端字节序，所以其值为 0x0002。以下为方便陈述，只说该字节序所表示的数值。这个是 e_type 属性，它占 2 字节，值为 2 表示类型为 ET_EXEC，即可执行文件（有兴趣的同学可以自行查看 Linux 下的.o 目标文件，其 e_type 类型是值为 1 的 ET_REL，即待重定位类型）。
  本行的第 2 个下画线处的内容是 0x0003，占 2 字节。该位置是 e_machine 属性，即 EM_386，表示该elf 文件是运行在 Intel 80386 平台。
  第 3 个下画线处的内容是 0x00000001，占 4 字节。该位置是 e_version 属性，即版本信息。
  第 4 个下画线处的内容是 0xc0001500，占 4 字节，该位置是 e_entry 属性，即程序的虚拟入口地址。
  第 5 个下画线处的内容是 0x00000034，占 4 字节，该位置是 e_phoff 属性，表示 program header table
  程序头表在文件中的偏移量，这里的偏移量是 0x34。
  
- 第三行。
  第 1 个下画线处的内容是 0x0000055c，占 4 字节，该位置是 e_shoff，表示 section header table 节头表在文件内的偏移量，这里的值为 0x55c，表示在本文件偏移 0x55c 字节处为节头表。之前说过啦，若没有节头表，此处便为 0。
  第 2 个下画线处的内容是 0x00000000，占 4 字节，该位置是 e_flags 属性。
  第 3 个下画线处的内容是 0x0034，占 2 字节，该位置是 e_ehsize 属性，表示 elf header 大小是 0x34字节。这和前面 e_phoff 属性值大小一致，可见，程序头表紧跟着 elf header 之后。
  第 4 个下画线处的内容是 0x0020，占 2 字节，该位置是 e_phentsize 属性，即 program header 的结构：struct Elf32_Phdr 的字节大小，值为 0x20 字节。
  第 5 个下画线处的内容是 0x0002，占 2 字节，该位置是 e_phnum 属性，即程序头表中段的个数，这里为 2 个段。
  第 6 个下画线处的内容是 0x0028，占 2 字节，该位置是 e_shentsize 属性，即节头表中各个节的大小。

- 第四行。
  第 1 个下画线处的内容是 0x0006，占 2 字节，该位置是 e_shnum 属性，即节头表中节的个数，这里表示有 6 个节。
  第 2 个下画线处的内容是 0x0003，占 2 字节，该位置是 e_shstrndx 属性，即 string name table 在节头表中的索引为 3。

  现在开始分析粗下画线范围的程序头表部分。
  从第 4 行到第 8 行是程序头表的范围，前面说过啦，程序头表中共有 2 个段，每个段大小是 0x20 字节。这有两个粗下画线，每个占 0x20 字节。大家注意图中，在两个粗下画线间有个小竖线，这是用来区分两个段的。竖线左右两边各是一个段。

  下面咱们按照 struct Elf32_Phdr 结构来分析，该结构中每个属性都占 4 字节，不再赘述。现在还是继
  续说图 5-37 的第 4 行。
  第 1 个粗下画线值为 0x00000001，该位置是 p_type 属性，值为 1，即表示 PT_LOAD 类型，可加载
  程序段，由于 kernel.bin 已经是链接后的可执行程序啦，所以，这 PT_LOAD 类型符合我们的认知。
  第 2 个粗下画线值为 0x00000000，该位置是 p_offset 属性，表示本段在文件内的偏移量。这个偏移量
  为 0，似乎很奇怪，这表示该段的起始是从文件头开始也算起啦，文件开头的部分不是 elf header 吗？不
  是代码啊，这是要闹哪样？好吧，到底是什么情况，一会儿咱们细说。
  第 3 个粗下画线值为 0xc0001000，该位置是 p_vaddr 属性，表示本段被加载到内存后的起始虚拟地址。
  看到这里，似乎觉得上面的p_offset为0有那么一点合理啦，结合elf header中的e_entry的值为0xc0101500，
  不知您想到了点什么？咱们先把剩下的说完。
  第 4 个粗下画线值为 0xc0001000，该位置是 p_paddr 属性，它通常和 p_vaddr 值一致，但该属性是保
  留项，咱们不用关注。
  第 5 个粗下画线值为 0x00000505，该位置是 p_filesz 属性，表示本段在文件中的字节大小。
  第 6 个粗下画线值也应该是 0x00000505，该位置是 p_memsz 属性，表示本段在内存中的大小，因为
  段无论在哪里，逻辑大小是不变的，故该值等于 p_filesz。
  第7 个粗下画线值为0x00000005，该位置是 p_flags 属性，表示与本段相关的标志。5=4+1=PF_R+PF_X，
  在此表示可读，可执行，根据此属性，我们推测此段为代码段。
  第 8 个粗下画线值为 0x00001000，该位置是 p_align 属性，表示本段对齐的方式。

- 该段的最后一字节是 0xc0001000+0x505= 
  0xc0001505。程序的起始地址是 0xc0001500，该段又是代码段（从该段的段标志 p_flags 值为 5 看出：可
  读可执行）这说明该段的实际代码长度是 0xc0001505-0xc0101500=5 字节。

![image-20231016113330814](/home/bulet/snap/typora/86/.config/Typora/typora-user-images/image-20231016113330814.png)

.text 表示下面开始定义代码，所以从第 2 行
的.text 看出，main.c 确实被汇编成了代码段，由 gcc
编译在第 3 行将_start 导出为全局符号，并在第 4
行声明_start 是个函数。方框中的第 5～7 行是一些
准备工作，属于堆栈框架的例行公事

重点是第 7～8 行的标号
和代码，jmp .L2。它们就是对应于 C 语言中的 while(1)。