### 页表原理详解

#### 内存不足，需要分页机制

![image-20231013162415305](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231013162415305.png)

我们所写的代码仅仅是完成了某件事的一部分而已，也许是大部分，**还有一部分是 CPU 硬件上负责的，这部分咱们不用管，由 CPU 自动完**成。比如，调用一个函数时，CPU 自动将返回地址压入栈，进入中断时，CPU 除了压入返回地址、标志寄存器外，还要根据当前特权级决定是否压入当前栈段寄存器及指针

##### 内存段是怎样被换出的，CPU 加载内存段

在保护模式下，段描述符是内存段的身份证。CPU 在引用一个段时，都要先查看段描述符。很多时候，段
描述符存在于描述符表中（GDT 或 LDT），但与此对应的段并不在内存中，也就是说，**CPU 允许在描述符表中**
**已注册的段不在内存中存在**，这就是它提供给软件使用的策略，我们利用它实现段式内存管理。

**如果该描述符中的 P 位为 1，表示该段在内存中存在**。**访问过该段后，CPU 将段描述符中的 A 位置 1**，表示近来刚访问过该段。
相反，**如果 P 位为 0，说明内存中并不存在该段，这时候 CPU 将会抛出个 NP（段不存在）异常**，转而去执行中
断描述符表中 NP 异常对应的中断处理程序，此中断处理程序是操作系统负责提供的，该程序的工作是将相应的
段从外存（比如硬盘）中载入到内存，并将段描述符的 P 位置 1，中断处理函数结束后返回，CPU 重复执行这个
检查，继续查看该段描述符的 P 位，此时已经为 1 了，在检查通过后，将段描述符的 A 位置 1。

##### 内存段是何时移出到外存上的呢

> 通过计算A置1的使用频率，找出不常用的段，换出到硬盘，当下次CPU运行，访问到了这个段，P为0然后异常换入内存段

##### 解决内存不足

> 解除线性地址与物理地址一一对应的关系，然后将它们的关系重新
> 建立。通过某种映射关系，可以将线性地址映射到任意物理地址。
>
> 对于地址转换这种实时性较高的需求，查找页表的工作也是由硬件完成的。



#### 分页机制的原理

![image-20231014094021966](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014094021966.png)

分页机制要建立在 分段机制的基础上，也就是说，段部件的工作依然免不了，所以，分页
只能是在分段之后进行的，

分页机制的作用有两方面。

- 将线性地址转换成物理地址。
- 用大小相等的页代替大小不等的段。

![image-20231014094340775](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014094340775.png)

即使在分页机制下的进程也要先经过逻辑上的分段才行，每加载一个进程，操作系统按照进程中各段的起始范围，在进程自己的 4GB 虚拟地址空间中寻找可用空间分配内存段，此虚拟地址空间可以是页表，也可以是操作系统维护的某种数据结构。

##### 大小确定：

![image-20231014095941477](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014095941477.png)



内存块大小则为 2 的 12 次方，即 4KB，内存块数量则为 2 的 20 次方，1M。

4GB 空间中可以容纳 1048576 个页，页表中自然也要有 1048576 个页表项，一级页表如图

![image-20231014100406885](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014100406885.png)



##### 如何将线性地址转换成物理地址呢？

用 20 位二进制就可以表示全部物理页啦。标准页都是 4KB，12 位二进制便可以表达 4KB
之内的任意地址。



物理地址写在页表的页表项中，段部件输出的只是线性地址

##### 怎样用线性地址找到页表中对应的页表项？

CPU 中集成了页部件当程序中给出一个线性地址时，页部件分析线性地址，自动在页表中检索到物理地址。

![image-20231014101549629](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014101549629.png)

（分页机制打开前要将页表地址加载到控制寄存器 cr3 中）

页部件分析 0x1234 的高20 位，用十六进制表示高 20 位是 0x00001。将此项作为页表项索引，再将该索引乘以 4 后加上 cr3 寄存器中**页表的物理地址**，这样便得到索引所指代的**页表项的物理地址**，从该物理地址处（页表项中）读取所映射的物理页地址：0x9000。之后加0x234和为 0x9234，这就是线性地址 0x1234 最终转换成的物理地址

用线性地址的高 20 位在页表中索引页表项，用线性地址的低 12 位与页表项中的物理地址相加，所求的和便是最终线性地址对应的物理地址。



#### 二级页表



##### 一级页表的不足

> （1）一级页表中最多可容纳 1M（1048576）个页表项，每个页表项是 4 字节，如果页表项全满的话，
> 便是 4MB 大小。
> （2）一级页表中所有页表项必须要提前建好，原因是操作系统要占用 4GB 虚拟地址空间的高 1GB，
> 用户进程要占用低 3GB。
> （3）每个进程都有自己的页表，进程一多，光是页表占用的空间就很可观了。



二级页表的大小

一级页表是将这 1M 个标准页放置到一张页表中，二级页表是将这 **1M 个标准页平均放置 1K 个**
**页表中**。则每个页表中包含有 1K 个页表项，页表项是 4 字节大小，故页表大小为
4KB。

这1K个页表则由专门的页目录表来存储，**每个页表的物**
**理地址在页目录表中都以页目录项（Page Directory Entry， PDE）的形式存储**，页目录表大小也为4KB

![image-20231014102639473](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014102639473.png)

##### 虚拟地址到物理地址转换方法：

32位虚拟地址高 10 位作为页表的索引，用于在页目录表中定位一个页目录项 PDE，页目录项中有页表物理地址，
也就是定位到了某个页表。中间 10 位作为物理页的索引，用于在页表内定位到某个页表项 PTE，页表项中有分
配的物理页地址，也就是定位到了某个物理页。低 12 位作为页内偏移量用于在已经定位到的物理页内寻址。

转换过程背后的具体步骤如下。
（1）用虚拟地址的高 10 位乘以 4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的
和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址。
（2）用虚拟地址的中间 10 位乘以 4，作为页表内的偏移地址，加上在第 1 步中得到的页表物理地址，
所得的和，便是页表项的物理地址。读取该页表项，从中获取到分配的物理页地址。
（3）虚拟地址的高 10 位和中间 10 位分别是 PDE 和 PTE 的索引值，所以它们需要乘以 4。但低 12 位
就不是索引值啦，其表示的范围是 0～0xfff，作为页内偏移最合适，所以虚拟地址的低 12 位加上第 2 步
中得到的物理页地址，所得的和便是最终转换的物理地址。

![image-20231014105538600](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014105538600.png)







##### 页目录项和页表项的结构：

![image-20231014105859546](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014105859546.png)

> 4 字节大小,只有第 12～31 位才是物理地址,目录项和页表项中的都是物理页地址，标准页大小是 4KB，故地址都是 4K 的倍数，也就是地址的低 12位是 0，所以只需要记录物理地址高 20 位就可以啦。这样省出来的 12 位（第 0～11 位）可以用来添加其他属性。



>P，Present，意为存在位。若为 1 表示该页存在于物理内存中，若为 0 表示该表不在物理内存中。操
>作系统的页式虚拟内存管理便是通过 P 位和相应的 pagefault 异常来实现的。
>
>RW，Read/Write，意为读写位。若为 1 表示可读可写，若为 0 表示可读不可写。
>
>US，User/Supervisor，意为普通用户/超级用户位。若为 1 时，表示处于 User 级，任意级别（0、1、2、
>3）特权的程序都可以访问该页。若为 0，表示处于 Supervisor 级，特权级别为 3 的程序不允许访问该页，
>该页只允许特权级别为 0、1、2 的程序可以访问。
>
>PWT，Page-level Write-Through，意为页级通写位，也称页级写透位。若为 1 表示此项采用通写方式，
>表示该页不仅是普通内存，还是高速缓存。此项和高速缓存有关，“通写”是高速缓存的一种工作方式，本位用来间接决定是否用此方式改善该页的访问效率。这里咱们直接置为 0 就可以啦。
>
>PCD，Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表
>示禁止将该页缓存。这里咱们将其置为 0。
>
>A，Accessed，意为访问位。若为 1 表示该页被 CPU 访问过啦，所以该位是由 CPU 设置的。还记得段
>描述符中的 A 位和 P 位吗？这两位在一起可以实现段式虚拟内存管理。和它们一样，这里页目录项和页表
>项中的 A 位也可以用来记录某一内存页的使用频率（操作系统定期将该位清 0，统计一段时间内变成 1 的次
>数），从而当内存不足时，可以将使用频率较低的页面换出到外存（如硬盘），同时将页目录项或页表项的 P
>位置 0，下次访问该页引起 pagefault 异常时，中断处理程序将硬盘上的页再次换入，同时将 P 位置 1。
>
>D，Dirty，意为脏页位。当 CPU 对一个页面执行写操作时，就会设置对应页表项的 D 位为 1。此项
>仅针对页表项有效，并不会修改页目录项中的 D 位。
>
>PAT，Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。比较复杂，将
>此位置 0 即可。
>
>G,Global，意为全局位。由于内存地址转换也是颇费周折，先得拆分虚拟地址，然后又要查页目录，又要
>查页表的，所以为了提高获取物理地址的速度，将虚拟地址与物理地址转换结果存储在 TLB（Translation
>Lookaside Buffer）中。
>此 G 位用来指定该页是否为全局页，为 1 表示是全局页，为 0 表示不是全局页。若为全局页，该页将在高速
>缓存 TLB 中一直保存，给出虚拟地址直接就出物理地址，无需那三步骤转换。由于 TLB 容量比较小（一般
>速度较快的存储设备容量都比较小），所以这里面就存放使用频率较高的页面。清空 TLB 有两种方式，一是用 invlpg 指令针对单独虚拟地址条目清理，或者是重新加载 cr3 寄存器，这将直接清空 TLB。
>
>AVL，意为 Available 位，表示可用，谁可以用？当然是软件，操作系统可用该位，CPU 不理会该位
>的值
