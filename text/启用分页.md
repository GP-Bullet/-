





启用分页机制，我们要按顺序做好三件事。
（1）准备好页目录表及页表。
（2）将页表地址写入控制寄存器 cr3。
（3）寄存器 cr0 的 PG 位置 1。PG 位为 1 后便进入了内存分页运行机制，段部件输出的线性地址成为虚拟地址

在将 PG 位置 1 之前，系统都是在内存分段机制下工作，段部件输出的线
性地址便直接是物理地址，也就意味着在第 2 步中，cr3 寄存器中的页表地址是真实的物理地址。

![image-20231014134639494](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014134639494.png)



![image-20231014141027530](/home/bullet/snap/typora/86/.config/Typora/typora-user-images/image-20231014141027530.png)

页目录表的位置，放在物理地址 0x100000 处

第一个页表的放在物理地址0x101000。





需要将虚拟地址 0xc0000000之上的 1MB 地址映射到物理内存 1MB 之内



#### 为什么要在两处指向同一个页表？



原因是我们在加载内核之前，程序中运行的一直都是 loader，它本身的代码都是在 1MB 之内，必须保证之前段机制下的线性地址和分页后的虚拟地址对应的物理地址一致。
**第 0 个页目录项代表的页表，其表示的空间是 0～0x3fffff，包括了 1MB（0～0xfffff），所以用了第 0 项来**
**保证 loader 在分页机制下依然运行正确。**

那为什么也要把该地址放置到第 768 项呢？前面说过啦，我们将来会把**操作系统内核放在低端 1M 物理内存空间，但操作系统的虚拟地址是 0xc0000000 以上，该虚拟地址对应的页目录项是第 768 个。**

这个算起来容易，0xc0000000 的高 10 位是 0x300，即十进制的 768。**这样虚拟地址 0xc0000000～0xc03fffff 之间的内存都指向的是低端 4MB 之内的物理地址，**这自然包括操作系统所占的低端 1MB 物理内存。从而实现了操作系统高 3GB 以上的虚拟地址对应到了低端 1MB，也就是如前所说我们内核所占的就是低端 1MB。

#### 用虚拟地址访问页表



提取出关键一点：高 10 位若为 0x3ff，则会访问到页目录表中最后一个页目录项，由于页表中也是
1024 个页表项，故中间 10 位若为 0x3ff，则会访问到页表中最后一个页表项。

如果虚拟地址的高 20 位为 0xfffff，经过我们的页目录表映射，将会访问到页目录表自
己的物理地址。



- 获 取页目录表物理地址：让虚拟地址的高 20 位为 0xfffff，低 12 位为 0x000，即 0xfffff000，这也
  是页目录表中第 0 个页目录项自身的物理地址。
- 访问页目录中的页目录项，即获取页表物理地址：要使虚拟地址为 0xfffffxxx，其中 xxx 是页目录项的索引乘以 4 的积。 



- 访问页表中的页表项：要使虚拟地址高 10 位为 0x3ff，目的是获取页目录表物理地址。中间 10 位为页表的索引，因为是 10 位的索引值，所以这里不用乘以 4。低 12 位为页表内的偏移地址，用来定位页表项，它必须是已经乘以 4 后的值。
  公式为 0x3ff<<22+中间 10 位<<12+低 12 位。



elf 文件格式的核心思想就是头中嵌头，是种层次化结构的格式。